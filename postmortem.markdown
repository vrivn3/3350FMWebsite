---
layout: page
title: Postmortem
permalink: /postmortem/
---

#### Dive into our process
**What went right in the development process?**

Our group had a relatively smooth development process when it came to developing our own features individually. Each member was able to complete their coding tasks without any major issues or delays, and none of the code that was produced by any member was of poor quality. While we didn't establish any strict coding standards or guidelines, each member was able to use a similar coding style throughout the development cycle. We had a solid understanding of our architecture throughout the development process, and understood when certain changes to a module would end up affecting other code. No group member was responsible for specific one architecture layer, or assigned a traditional role. We were each responsible for all layers of our application when developing new features, and we believe this benefitted our overall development process as each member had a fundamental understanding of the project architecture and the code modules even if they did not work on a specific feature. 
  
We adopted a development style where each team member had the freedom to implement their assigned features with the way they envisioned, with slight team input during the planning process to ensure that the implementation would be realistic. We believe this benefitted our project in the grand scheme of things, as allowing everyone to exercise their creativity is crucial to producing meaningful work. Our codebase was also subject to refactoring in each iteration to reduce code smells and technical debt left over from previous iterations, as well as increasing modularization and readability by breaking down large components into smaller ones. This ensured that our system remained clean and healthy after each iteration to ensure the development process of the next iteration went smoothly.

**What went wrong in the development process?**

Our integration of an HSQLDB relational database proved to be a difficult task for what we believe to be a couple reasons. The most prominent issue was that we began integrating the database near the end of the iteration 2 timeline, which we now believe wasn't the right decision. We underestimated the time and effort it would take to iron out all the kinks of setting up HSQLDB, which was a rather tedious endeavour. This meant that certain logic classes that interacted with the HSQLDB persistence implementations would repeatedly call the database even when it was not necessary when loading activities and querying data. These issues led to a few significant performance issues and bugs with one of our HSQLDB implementations which cost us when we released iteration 2.
	
Certain standards pertaining to GitLab management and coding were inconsistent throughout the development process as well. Certain members would utilize consistent branching techniques when developing new features or coding tasks, while others would merge code straight into main. While this wasn't the biggest issue we encountered, it did add unnecessary complexity to the development progress, especially when merging feature branches into the main branch near the end of an iteration when everyone was finishing up their work. Additionally, certain GitLab issues such as user stories would be missing time estimates and time spent, along with priorities which had to be updated by other team members before the release of an iteration. We also found that we were spending time finishing up certain coding and project management tasks on the iteration 1 and 2 release days, which made the release stressful. This was likely due to improper time management.

These issues were identified in our iteration 2 retrospection. To remedy them moving into iteration 3, a significant rework of our code was completed after the release of iteration 2 and before we began the planning for iteration 3 to ensure that the database implementation would not stunt the progress of iteration 3. Additionally, we ensured that any critical tasks that needed to be completed such as new features would be prioritized over others. We set stricter deadlines for these tasks as stated in the retrospective, and we believe this helped iteration 3 proceed more smoothly. All of the features we needed were completed a few days before the release of iteration 3, which allowed us a significant portion of time to test and complete the presentation website for release, rather than scrambling to complete the iteration.

**How did the project change from your initial (iteration 0) vision or stories, or did it work out as predicted?**
	
We had a clear goal of what we wanted to accomplish with our application. Our vision was united from the start and we never strayed away from that vision at any point throughout any iteration despite our initial concerns that certain features such as recommendations and following users would be difficult to implement. A comprehensive planning process at the start of iteration 0 was held which outlined exactly which features we believed would be realistic to implement throughout three iterations. While some features were moved into their successive iterations, each feature we planned to implement during the planning phase in iteration 0 was successfully completed by end of iteration 3. We attribute this to the detailed planning meetings that were held at the start of each iteration to gauge which features would need to be completed in order for the project to grow smoothly.

**What did you learn about team or large project development? What will you start doing, keep doing, or stop doing next time?**
	
We learned a lot about team and large project development throughout the development of 3350FM. We learned that communication amongst the group as a whole is critical throughout an iteration, as it keeps everyone in touch with the reality of the state of development. While we ensured that we held a group meeting at the start of each iteration to plan out who would tackle certain features and other dev tasks, we did not hold consistent group meet ups throughout the remainder of the iteration time frame. Holding some kind of semi-frequent traditional "stand-up" throughout iterations would've ensured that each member was aware of the state of the project, and what areas needed more attention which is something each member will try to adopt in future projects. Regardless, we still communicated outside of traditional group meetings via Discord to ask and answer questions, as well as keeping each member informed about any changes to the codebase such as pull requests and merges. 

We also learned that large project development requires consistent upkeep and maintenance, which significantly improved our projects development cycle and we will ensure that future endeavours will adopt this same mindset moving forward.

**Can you draw any conclusions from what youâ€™ve done?**

We are proud of what we were able to accomplish with 3350FM. From the start, we envisioned creating a music cataloguing application that would allow users to manage, critique, and share music with others. We believe we were able to fulfill that original vision. We can conclude that the most important aspect of building software in a collaborative environment is communication between team members, ensuring that the scope of each iteration is realistic, and allowing each member of the team to have a say in the development process. We can also conclude that time management is critical to ensuring releases are complete without any significant bugs or performance issues, and that completing crucial components in a project such as relational databases should be prioritized before other features.